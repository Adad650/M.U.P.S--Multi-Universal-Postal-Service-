<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>M.U.P.S — Loading Dimension</title>
  <style>
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 0;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #1c1c30, #07070b 60%);
      font-family: "Segoe UI", "Inter", system-ui, sans-serif;
    }
    canvas {
      border: 3px solid #2b2d45;
      box-shadow: 0 30px 60px rgba(5, 7, 15, 0.75);
      background: #05050a;
    }
  </style>
</head>
<body>
  <canvas id="game" width="800" height="600" aria-label="M.U.P.S — Loading Dimension"></canvas>
  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    const screenWidth = canvas.width;
    const screenHeight = canvas.height;

    const playerSpriteSources = [
      "https://cdn.jsdelivr.net/gh/Adad650/M.U.P.S--Multi-Universal-Postal-Service-@main/assets/walking/postman_walk_pixel_sheet.png",
      "assets/walking/postman_walk_pixel_sheet.png",
    ];
    const playerSpriteFrameCount = 16;
    const playerSpriteScale = 0.7;
    const playerAnimFrameTime = 90;
    const playerSprintMultiplier = 1.7;

    const GameState = {
      HUB: "Hub",
      CONTRACT_MENU: "Contract",
      SHOP: "Shop",
      LEVEL: "Level",
      WIN: "Win",
      GAME_OVER: "GameOver",
    };

    const floorY = 520;
    const hubDoorRect = { x: 40, y: floorY - 150, width: 52, height: 150 };
    const portalRect = { x: screenWidth - 188, y: floorY - 160, width: 90, height: 160 };
    const deskRect = { x: 60, y: floorY - 40, width: 200, height: 40 };
    const shopCounterRect = { x: screenWidth / 2 - 90, y: floorY - 40, width: 180, height: 40 };
    const levelDoorWidth = 52;
    const levelDoorHeight = 150;
    const levelDoorMinTop = 80;
    let levelDoorRect = { x: 0, y: 0, width: 0, height: 0 };
    let levelBackdropOrbs = [];
    let levelNeedsBuild = false;
    const computerInteractRect = {
      x: deskRect.x - 30,
      y: deskRect.y - 110,
      width: deskRect.width + 60,
      height: deskRect.height + 130,
    };
    const shopInteractRect = {
      x: shopCounterRect.x - 40,
      y: shopCounterRect.y - 120,
      width: shopCounterRect.width + 80,
      height: shopCounterRect.height + 140,
    };

    const namePrefixes = [
      "Aurora",
      "Nova",
      "Echo",
      "Titan",
      "Quantum",
      "Lumen",
      "Vortex",
      "Atlas",
      "Stellar",
      "Gale",
      "Eclipse",
      "Oracle",
    ];
    const nameSuffixes = [
      "Run",
      "Circuit",
      "Relay",
      "Shift",
      "Route",
      "Track",
      "Dash",
      "Spiral",
      "Passage",
      "Traverse",
      "Vector",
      "Expedition",
    ];
    const hazardDescriptors = [
      "charged dust lanes",
      "volatile thermal vents",
      "graviton storms",
      "magnetic shear pockets",
      "nebula acid rain",
      "rogue drone fields",
      "unstable warp echoes",
      "fractured bridgework",
    ];
    const difficultyScale = [
      [0.45, "Routine Route"],
      [0.7, "Risky Run"],
      [0.95, "Hazard Sweep"],
      [1.2, "Critical Gauntlet"],
      [10.0, "Impossible Route"],
    ];

    const CONTRACT_ARCHETYPES = [
      {
        key: "courier_cruise",
        tier: "easy",
        tagline: "Courier Cruise",
        summary: "Training loop with generous landing pads.",
        difficultyRange: [0.35, 0.5],
        gapMul: [0.75, 0.9],
        widthMul: [1.2, 1.35],
        lifeBonus: 1,
        gravityOffset: -0.02,
        traits: ["+1 support drone", "Wide landing pads"],
      },
      {
        key: "express_dash",
        tier: "medium",
        tagline: "Express Relay",
        summary: "Rush contracts with long sprints and bonus pay.",
        difficultyRange: [0.55, 0.85],
        gapMul: [1.05, 1.2],
        widthMul: [0.9, 1.0],
        horizontalBias: 1.25,
        payoutBonus: 0.15,
        traits: ["+15% payout", "Long sprint sections"],
      },
      {
        key: "precision_shift",
        tier: "medium",
        tagline: "Precision Shift",
        summary: "Compact pads that reward careful jumps.",
        difficultyRange: [0.65, 0.95],
        gapMul: [1.0, 1.15],
        widthMul: [0.75, 0.9],
        xpBonus: 0.15,
        traits: ["Compact pads", "+15% XP bounty"],
      },
      {
        key: "spireline_gauntlet",
        tier: "hard",
        tagline: "Spireline Contract",
        summary: "Vertical shafts carved between floating towers.",
        difficultyRange: [0.9, 1.2],
        gapMul: [0.95, 1.05],
        widthMul: [0.8, 0.9],
        verticalBias: 1.35,
        wallJump: true,
        traits: ["Wall-jump thrusters online", "Vertical shaft routing"],
      },
      {
        key: "hazard_sweep",
        tier: "hard",
        tagline: "Hazard Sweep",
        summary: "Toxic fields with premium payout for precision.",
        difficultyRange: [1.0, 1.3],
        gapMul: [1.2, 1.35],
        widthMul: [0.65, 0.8],
        gravityOffset: 0.04,
        lifeBonus: -1,
        payoutBonus: 0.25,
        xpBonus: 0.1,
        traits: ["Tiny pads", "+25% hazard pay", "-1 drone"],
      },
    ];

    const shopItems = [
      {
        key: "premium_routes",
        name: "Premium Routes License",
        description: "+20% contract payouts.",
        cost: 250,
        type: "mission_bonus",
        value: 1.2,
        maxStacks: 1,
      },
      {
        key: "extra_life",
        name: "Auxiliary Drone",
        description: "+1 life on every mission.",
        cost: 200,
        type: "extra_life",
        value: 1,
        maxStacks: 1,
      },
      {
        key: "color_mint",
        name: "Suit Paint - Neon Mint",
        description: "Fresh mint glow for your suit.",
        cost: 120,
        type: "player_color",
        value: [120, 255, 200],
        maxStacks: 1,
      },
      {
        key: "color_violet",
        name: "Suit Paint - Royal Violet",
        description: "Stand out with deep royal hues.",
        cost: 120,
        type: "player_color",
        value: [190, 120, 255],
        maxStacks: 1,
      },
      {
        key: "decor_plant",
        name: "Office Hanging Planter",
        description: "Adds greenery to the office.",
        cost: 90,
        type: "decor",
        value: "plant",
        maxStacks: 1,
      },
      {
        key: "decor_poster",
        name: "Skyline Poster",
        description: "Add a skyline view to the wall.",
        cost: 110,
        type: "decor",
        value: "poster",
        maxStacks: 1,
      },
    ];

    const shopVisibleRows = 4;

    let gameState = GameState.HUB;
    let contracts = [];
    let selectedContractIndex = 0;
    let shopSelectionIndex = 0;
    let shopScrollOffset = 0;
    let playerLevel = 1;
    let playerXP = 0;
    let xpForNextLevel = 120;
    let playerMoney = 0;
    let livesRemaining = 0;
    let missionPayMultiplier = 1.0;
    let extraLifeBonus = 0;
    let playerColor = [255, 255, 255];
    let officeDecor = "standard";
    const ownedUpgrades = {};
    let shopMessage = "Welcome to the Supply Depot.";
    let portalActive = false;

    let currentContract = null;
    let levelPlatforms = [];
    let levelLength = 0;
    let player = createPlayer();
    let playerWalkTimer = 0;
    let playerAnimIndex = 0;
    let playerSprite = null;
    let playerSpriteLoaded = false;
    let playerFrameWidth = 0;
    let playerFrameHeight = 0;
    let playerSpriteAttempt = 0;
    let playerMoving = false;

    const keysDown = new Set();
    let lastTimestamp = 0;

    const winSummary = { payment: 0, xp: 0, contract: "", moneyTotal: 0, level: 1 };
    const gameOverSummary = { contract: "", reason: "Out of lives" };

    let sliderTicker = 0;

    function loadPlayerSprite() {
      const src = playerSpriteSources[playerSpriteAttempt];
      playerSpriteLoaded = false;
      playerFrameWidth = 0;
      playerFrameHeight = 0;
      const image = new Image();
      image.crossOrigin = "anonymous";
      image.onload = () => {
        playerSprite = image;
        playerSpriteLoaded = true;
        playerFrameWidth = playerSprite.width / playerSpriteFrameCount;
        playerFrameHeight = playerSprite.height;
      };
      image.onerror = () => {
        playerSpriteAttempt += 1;
        if (playerSpriteAttempt < playerSpriteSources.length) {
          loadPlayerSprite();
        }
      };
      image.src = src;
    }
    loadPlayerSprite();

    function createPlayer() {
      return {
        x: 120,
        y: floorY - 70,
        width: 32,
        height: 48,
        velX: 0,
        velY: 0,
        onGround: false,
        facing: 1,
      };
    }

    function clamp(value, min, max) {
      return Math.max(min, Math.min(max, value));
    }

    function sampleRange(value, fallback) {
      if (value == null) {
        return fallback;
      }
      if (Array.isArray(value) && value.length) {
        if (value.length === 1) {
          return value[0];
        }
        return value[0] + Math.random() * (value[1] - value[0]);
      }
      return value;
    }

    function mixColors(a, b, t) {
      return [
        Math.round(a[0] + (b[0] - a[0]) * t),
        Math.round(a[1] + (b[1] - a[1]) * t),
        Math.round(a[2] + (b[2] - a[2]) * t),
      ];
    }

    function pickContractProfiles(count) {
      const selected = [];
      const used = new Set();
      const tiers = ["easy", "medium", "hard"];
      for (const tier of tiers) {
        if (selected.length >= count) break;
        const options = CONTRACT_ARCHETYPES.filter((arch) => arch.tier === tier && !used.has(arch.key));
        if (!options.length) continue;
        const choice = options[Math.floor(Math.random() * options.length)];
        selected.push(choice);
        used.add(choice.key);
      }
      const remaining = CONTRACT_ARCHETYPES.filter((arch) => !used.has(arch.key));
      while (selected.length < count) {
        if (!remaining.length) break;
        const choice = remaining.splice(Math.floor(Math.random() * remaining.length), 1)[0];
        selected.push(choice);
      }
      while (selected.length < count) {
        selected.push(CONTRACT_ARCHETYPES[Math.floor(Math.random() * CONTRACT_ARCHETYPES.length)]);
      }
      return selected.sort(() => Math.random() - 0.5).slice(0, count);
    }

    function buildContractFromArchetype(archetype) {
      const difficultyRange = Array.isArray(archetype.difficultyRange)
        ? archetype.difficultyRange
        : [0.35, 1.05];
      const baseDifficulty = difficultyRange[0] + Math.random() * (difficultyRange[1] - difficultyRange[0]);
      const gravity = clamp(0.45 + baseDifficulty * 0.35 + (archetype.gravityOffset || 0) + (Math.random() * 0.04 - 0.02), 0.45, 0.9);
      const gapMin = clamp(60 + baseDifficulty * 55 + Math.random() * 16 - 8, 40, 180);
      const gapMax = gapMin + 30 + baseDifficulty * 80;
      const widthMax = Math.max(120, 260 - baseDifficulty * 110 + (Math.random() * 24 - 12));
      const widthMin = widthMax - Math.max(40, baseDifficulty * 45);
      const lives = Math.max(1, 3 - Math.floor(baseDifficulty * 2) + (archetype.lifeBonus || 0));
      let difficultyScore = baseDifficulty;
      difficultyScore += Math.max(0, (gapMin - 70) / 140);
      difficultyScore += Math.max(0, (200 - widthMax) / 200);
      difficultyScore = clamp(difficultyScore, 0.35, 1.6);
      let payment = Math.round(140 + difficultyScore * 340 + Math.random() * 20 - 10);
      let xpReward = Math.round(80 + difficultyScore * 240);
      if (archetype.payoutBonus) {
        payment = Math.round(payment * (1 + archetype.payoutBonus));
      }
      if (archetype.xpBonus) {
        xpReward = Math.round(xpReward * (1 + archetype.xpBonus));
      }
      let label = "Unknown Route";
      for (const [threshold, tag] of difficultyScale) {
        if (difficultyScore <= threshold) {
          label = tag;
          break;
        }
      }
      const hazardText = hazardDescriptors[Math.floor(Math.random() * hazardDescriptors.length)];
      const modifiers = archetype.traits ? [...archetype.traits] : [];
      const description = `${archetype.tagline} — ${archetype.summary || label} through ${hazardText}.`;
      const name = `${namePrefixes[Math.floor(Math.random() * namePrefixes.length)]} ${nameSuffixes[Math.floor(Math.random() * nameSuffixes.length)]}`;
      return {
        key: archetype.key,
        name,
        description,
        lives,
        xp: xpReward,
        payment,
        difficulty: difficultyScore,
        label,
        hazard: hazardText,
        modifiers,
        wallJump: Boolean(archetype.wallJump),
        gapRange: [gapMin, gapMax],
        widthRange: [Math.max(70, widthMin), Math.max(90, widthMax)],
      };
    }

    function refreshContracts() {
      contracts = pickContractProfiles(3).map(buildContractFromArchetype);
      selectedContractIndex = 0;
    }

    function getPlayerRect() {
      return { x: player.x, y: player.y, width: player.width, height: player.height };
    }

    function rectsIntersect(a, b) {
      return a.x + a.width > b.x && a.x < b.x + b.width && a.y + a.height > b.y && a.y < b.y + b.height;
    }

    function createLevel(contract) {
      const platforms = [];
      const baseY = floorY - 130;
      let x = 0;
      platforms.push({ x: 0, y: floorY - 60, width: 200, height: 24, isStart: true });
      x += 200 + 30;
      for (let i = 0; i < 18; i++) {
        const gap = contract.gapRange[0] + Math.random() * (contract.gapRange[1] - contract.gapRange[0]);
        const width = contract.widthRange[0] + Math.random() * (contract.widthRange[1] - contract.widthRange[0]);
        const y = baseY + Math.sin((x / 1000) * Math.PI * 2) * 40 - Math.random() * 30;
        platforms.push({ x, y: Math.min(floorY - 70, Math.max(260, y)), width, height: 18 });
        x += width + gap;
      }
      platforms.push({ x: x + 40, y: baseY - 20, width: 300, height: 22, isEnd: true });
      const endPlatform = platforms[platforms.length - 1];
      levelLength = endPlatform.x + endPlatform.width;
      levelPlatforms = platforms;
      player.x = platforms[0].x + 40;
      player.y = platforms[0].y - player.height;
      player.velX = 0;
      player.velY = 0;
      player.onGround = true;
      player.facing = 1;
      sliderTicker = 0;
      const doorLeft = Math.max(endPlatform.x + endPlatform.width / 2 - levelDoorWidth / 2, endPlatform.x + 10);
      const desiredDoorTop = endPlatform.y - levelDoorHeight;
      const doorTop = Math.max(levelDoorMinTop, desiredDoorTop);
      levelDoorRect = {
        x: doorLeft,
        y: doorTop,
        width: levelDoorWidth,
        height: levelDoorHeight,
      };
      buildLevelBackdrop();
      levelNeedsBuild = false;
    }

    function buildLevelBackdrop() {
      const orbCount = 26;
      const maxX = Math.max(levelLength, screenWidth * 1.1);
      levelBackdropOrbs = [];
      for (let i = 0; i < orbCount; i++) {
        const radius = Math.random() * 12 + 6;
        const y = Math.random() * (floorY - 100) + 40;
        const teal = 160 + Math.floor(Math.random() * 80);
        const lavender = 190 + Math.floor(Math.random() * 60);
        levelBackdropOrbs.push({
          x: Math.random() * (maxX + 200),
          y,
          radius,
          parallax: Math.random() * 0.3 + 0.15,
          color: `rgba(${lavender}, ${teal}, 255, ${0.2 + Math.random() * 0.35})`,
        });
      }
    }

    function queueContract(contract) {
      currentContract = contract;
      livesRemaining = contract.lives + extraLifeBonus;
      missionPayMultiplier = Math.max(1, missionPayMultiplier);
      levelNeedsBuild = true;
      levelDoorRect = { x: 0, y: 0, width: 0, height: 0 };
      levelBackdropOrbs = [];
      portalActive = true;
      shopMessage = `Contract queued: ${contract.name}. Walk into the portal to begin.`;
      gameState = GameState.HUB;
    }

    function completeContract() {
      const payout = Math.round(currentContract.payment * missionPayMultiplier);
      playerMoney += payout;
      addXP(currentContract.xp);
      winSummary.payment = payout;
      winSummary.xp = currentContract.xp;
      winSummary.contract = currentContract.name;
      winSummary.moneyTotal = playerMoney;
      winSummary.level = playerLevel;
      portalActive = false;
      levelDoorRect = { x: 0, y: 0, width: 0, height: 0 };
      levelPlatforms = [];
      levelLength = 0;
      levelBackdropOrbs = [];
      gameState = GameState.WIN;
    }

    function failContract(reason) {
      gameOverSummary.contract = currentContract ? currentContract.name : "Contract";
      gameOverSummary.reason = reason;
      portalActive = false;
      levelDoorRect = { x: 0, y: 0, width: 0, height: 0 };
      levelPlatforms = [];
      levelLength = 0;
      levelBackdropOrbs = [];
      gameState = GameState.GAME_OVER;
    }

    function addXP(amount) {
      playerXP += amount;
      while (playerXP >= xpForNextLevel) {
        playerXP -= xpForNextLevel;
        playerLevel += 1;
        xpForNextLevel = Math.round(xpForNextLevel * 1.2 + 10);
      }
    }

    function purchaseItem(item) {
      const owned = ownedUpgrades[item.key] || 0;
      if (owned >= item.maxStacks) {
        shopMessage = `${item.name} already installed.`;
        return;
      }
      if (playerMoney < item.cost) {
        shopMessage = "You need more M.U.P.S credits.";
        return;
      }
      playerMoney -= item.cost;
      ownedUpgrades[item.key] = owned + 1;
      switch (item.type) {
        case "mission_bonus":
          missionPayMultiplier = item.value;
          shopMessage = `${item.name} unlocked: +${Math.round((item.value - 1) * 100)}% payout.`;
          break;
        case "extra_life":
          extraLifeBonus = item.value;
          shopMessage = "Auxiliary Drone online. Extra life added.";
          break;
        case "player_color":
          playerColor = item.value;
          shopMessage = `${item.name} applied.`;
          break;
        case "decor":
          officeDecor = item.value;
          shopMessage = "Office decor updated.";
          break;
        default:
          shopMessage = `${item.name} acquired.`;
      }
    }

    const movementKeyCodes = new Set([
      "Space",
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight",
      "KeyW",
      "KeyA",
      "KeyS",
      "KeyD",
      "KeyE",
      "KeyR",
      "Enter",
      "NumpadEnter",
      "Escape",
    ]);
    document.addEventListener("keydown", (event) => {
      if (movementKeyCodes.has(event.code)) {
        event.preventDefault();
      }
      keysDown.add(event.code);
      handleKey(event.code);
    });
    document.addEventListener("keyup", (event) => {
      keysDown.delete(event.code);
    });

    function handleKey(code) {
      if (gameState === GameState.CONTRACT_MENU) {
        if (code === "ArrowUp" || code === "KeyW") {
          selectedContractIndex = (selectedContractIndex - 1 + contracts.length) % contracts.length;
        } else if (code === "ArrowDown" || code === "KeyS") {
          selectedContractIndex = (selectedContractIndex + 1) % contracts.length;
        } else if (code === "Enter" || code === "NumpadEnter" || code === "KeyE") {
          queueContract(contracts[selectedContractIndex]);
        } else if (code === "Escape") {
          gameState = GameState.HUB;
        }
        return;
      }

      if (gameState === GameState.SHOP) {
        if (code === "ArrowUp" || code === "KeyW") {
          shopSelectionIndex = Math.max(0, shopSelectionIndex - 1);
          shopScrollOffset = Math.max(0, shopSelectionIndex - shopVisibleRows + 1);
        } else if (code === "ArrowDown" || code === "KeyS") {
          shopSelectionIndex = Math.min(shopItems.length - 1, shopSelectionIndex + 1);
          if (shopSelectionIndex > shopScrollOffset + shopVisibleRows - 1) {
            shopScrollOffset = shopSelectionIndex - shopVisibleRows + 1;
          }
        } else if (code === "Enter" || code === "NumpadEnter" || code === "KeyE") {
          purchaseItem(shopItems[shopSelectionIndex]);
        } else if (code === "Escape") {
          gameState = GameState.HUB;
        }
        return;
      }

      if (gameState === GameState.HUB) {
        const playerRect = getPlayerRect();
        const nearComputer = rectsIntersect(playerRect, computerInteractRect);
        const nearShop = rectsIntersect(playerRect, shopInteractRect);
        if (code === "KeyE" && nearComputer) {
          refreshContracts();
          gameState = GameState.CONTRACT_MENU;
        } else if (code === "KeyR" && nearShop) {
          gameState = GameState.SHOP;
        }
        return;
      }

      if (gameState === GameState.WIN || gameState === GameState.GAME_OVER) {
        if (code === "Enter" || code === "NumpadEnter" || code === "KeyE") {
          gameState = GameState.HUB;
          currentContract = null;
        }
      }
    }

    function updatePlayer(dt) {
      const sprintMultiplier = keysDown.has("ShiftLeft") || keysDown.has("ShiftRight") ? playerSprintMultiplier : 1;
      let move = 0;
      if (keysDown.has("KeyA") || keysDown.has("ArrowLeft")) {
        move -= 1;
      }
      if (keysDown.has("KeyD") || keysDown.has("ArrowRight")) {
        move += 1;
      }
      player.velX = move * 5 * sprintMultiplier;
      if (move !== 0) {
        player.facing = move > 0 ? 1 : -1;
      }
      playerMoving = move !== 0;
      const jumpPressed = keysDown.has("Space") || keysDown.has("KeyW") || keysDown.has("ArrowUp");
      if (jumpPressed && player.onGround) {
        player.velY = -11;
        player.onGround = false;
      }
      player.velY += 0.6;
      player.x += player.velX;
      player.y += player.velY;
      if (gameState === GameState.LEVEL) {
        player.onGround = false;
        for (const platform of levelPlatforms) {
          const playerBottom = player.y + player.height;
          const platformTop = platform.y;
          const playerMidX = player.x + player.width * 0.5;
          if (
            playerBottom >= platformTop - 1 &&
            playerBottom <= platformTop + 20 &&
            playerMidX >= platform.x - 10 &&
            playerMidX <= platform.x + platform.width + 10 &&
            player.velY >= 0
          ) {
            player.y = platformTop - player.height;
            player.velY = 0;
            player.onGround = true;
          }
        }
        if (player.y > screenHeight) {
          livesRemaining -= 1;
          if (livesRemaining <= 0) {
            failContract("Out of lives");
          } else {
            resetPlayer();
          }
        }
        if (levelDoorRect.width && rectsIntersect(getPlayerRect(), levelDoorRect)) {
          completeContract();
        }
      } else {
        player.velY = 0;
        player.y = Math.min(player.y, floorY - player.height);
        if (player.y >= floorY - player.height) {
          player.onGround = true;
        }
        if (player.x < 0) {
          player.x = 0;
        }
        if (player.x > screenWidth - player.width) {
          player.x = screenWidth - player.width;
        }
        if (portalActive && currentContract && rectsIntersect(getPlayerRect(), portalRect)) {
          levelNeedsBuild = true;
          gameState = GameState.LEVEL;
        }
      }
    }

    function resetPlayer() {
      const start = levelPlatforms.find((platform) => platform.isStart) || levelPlatforms[0];
      player.x = start.x + 40;
      player.y = start.y - player.height;
      player.velY = 0;
      player.onGround = true;
    }

    function loop(timestamp) {
      const delta = timestamp - lastTimestamp;
      lastTimestamp = timestamp;
      if (gameState === GameState.LEVEL && levelNeedsBuild && currentContract) {
        createLevel(currentContract);
      }
      sliderTicker += delta * 0.002;
      const canMove = gameState === GameState.LEVEL || gameState === GameState.HUB;
      if (canMove) {
        updatePlayer(delta);
        if (playerMoving) {
          playerWalkTimer += delta;
          if (playerWalkTimer >= playerAnimFrameTime) {
            playerWalkTimer -= playerAnimFrameTime;
            playerAnimIndex = (playerAnimIndex + 1) % playerSpriteFrameCount;
          }
        } else {
          playerWalkTimer = 0;
          playerAnimIndex = 0;
        }
      } else {
        playerWalkTimer = 0;
        playerAnimIndex = 0;
      }
      draw();
      requestAnimationFrame(loop);
    }

    function drawBackground() {
      ctx.fillStyle = "#030512";
      ctx.fillRect(0, 0, screenWidth, screenHeight);
      const gradient = ctx.createLinearGradient(0, 0, 0, screenHeight);
      gradient.addColorStop(0, "rgba(38, 42, 68, 0.88)");
      gradient.addColorStop(0.6, "rgba(5, 7, 18, 0.95)");
      gradient.addColorStop(1, "rgba(2, 3, 8, 0.98)");
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, screenWidth, screenHeight);
      ctx.save();
      ctx.globalAlpha = 0.55;
      const halo = ctx.createRadialGradient(screenWidth * 0.25, screenHeight * 0.25, 20, screenWidth * 0.25, screenHeight * 0.25, 280);
      halo.addColorStop(0, "rgba(115, 180, 255, 0.4)");
      halo.addColorStop(1, "rgba(5, 5, 20, 0)");
      ctx.fillStyle = halo;
      ctx.fillRect(0, 0, screenWidth, screenHeight);
      ctx.restore();
      if (gameState === GameState.LEVEL) {
        drawLevelBackdropGrid();
      } else {
        drawHubAtmosphere();
      }
    }

    function drawLevelBackdropGrid() {
      const lineColor = "rgba(255,255,255,0.04)";
      ctx.save();
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 1;
      const spacing = 26;
      for (let x = -spacing; x < screenWidth + spacing; x += spacing) {
        ctx.beginPath();
        ctx.moveTo(x - (sliderTicker % spacing), 0);
        ctx.lineTo(x - (sliderTicker % spacing), screenHeight);
        ctx.stroke();
      }
      for (let y = 0; y < screenHeight; y += spacing * 2) {
        ctx.beginPath();
        ctx.moveTo(0, y + (sliderTicker % (spacing * 2)));
        ctx.lineTo(screenWidth, y + (sliderTicker % (spacing * 2)));
        ctx.stroke();
      }
      ctx.restore();
    }

    function drawHubAtmosphere() {
      ctx.save();
      ctx.globalCompositeOperation = "lighter";
      ctx.globalAlpha = 0.35;
      const glow = ctx.createRadialGradient(portalRect.x + portalRect.width / 2, portalRect.y + portalRect.height / 2, 10, portalRect.x + portalRect.width / 2, portalRect.y + portalRect.height / 2, 160);
      glow.addColorStop(0, "rgba(98, 255, 210, 0.45)");
      glow.addColorStop(1, "rgba(3, 7, 18, 0)");
      ctx.fillStyle = glow;
      ctx.fillRect(0, 0, screenWidth, screenHeight);
      ctx.restore();
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.fillStyle = "#101421";
      ctx.fillRect(0, floorY - 40, screenWidth, 160);
      ctx.restore();
    }

    function drawLevel() {
      if (!levelPlatforms.length) return;
      if (levelBackdropOrbs.length) {
        for (const orb of levelBackdropOrbs) {
          const orbX = orb.x - cameraX() * orb.parallax;
          if (orbX < -orb.radius * 2 || orbX > screenWidth + orb.radius * 2) {
            continue;
          }
          ctx.beginPath();
          ctx.arc(orbX, orb.y, orb.radius, 0, Math.PI * 2);
          ctx.fillStyle = orb.color;
          ctx.fill();
        }
      }
      for (const platform of levelPlatforms) {
        ctx.fillStyle = platform.isEnd ? "#7a9bff" : "#c8cff0";
        ctx.fillRect(platform.x - cameraX(), platform.y, platform.width, platform.height);
      }
      if (levelDoorRect.width) {
        const doorX = levelDoorRect.x - cameraX();
        ctx.fillStyle = "#4d4ff5";
        ctx.fillRect(doorX, levelDoorRect.y, levelDoorRect.width, levelDoorRect.height);
        ctx.strokeStyle = "#bfdbff";
        ctx.lineWidth = 3;
        ctx.strokeRect(doorX, levelDoorRect.y, levelDoorRect.width, levelDoorRect.height);
        ctx.lineWidth = 1;
        ctx.fillStyle = "#cfe3ff";
        ctx.font = "12px 'Segoe UI', system-ui";
        ctx.fillText("Exit Portal", doorX - 4, levelDoorRect.y + levelDoorRect.height / 2);
      }
      ctx.fillStyle = "rgba(255, 255, 255, 0.08)";
      ctx.font = "18px 'Segoe UI', system-ui";
      ctx.fillText(`Hazard: ${currentContract.hazard}`, 20, 60);
    }

    function cameraX() {
      const pad = 150;
      return clamp(player.x - screenWidth / 2, 0, Math.max(0, levelLength - screenWidth + pad));
    }

    function drawPlayer() {
      const drawX = player.x - cameraX();
      const drawY = player.y;
      if (playerSpriteLoaded && playerFrameWidth && playerFrameHeight) {
        const animIdx = playerAnimIndex % playerSpriteFrameCount;
        const sx = animIdx * playerFrameWidth;
        const sy = 0;
        const destWidth = Math.max(1, Math.round(playerFrameWidth * playerSpriteScale));
        const destHeight = Math.max(1, Math.round(playerFrameHeight * playerSpriteScale));
        ctx.save();
        ctx.translate(drawX + player.width / 2, drawY + player.height);
        ctx.scale(player.facing, 1);
        ctx.drawImage(
          playerSprite,
          sx,
          sy,
          playerFrameWidth,
          playerFrameHeight,
          -destWidth / 2,
          -destHeight,
          destWidth,
          destHeight
        );
        ctx.restore();
      } else {
        ctx.fillStyle = `rgb(${playerColor.join(",")})`;
        ctx.fillRect(drawX, drawY, player.width, player.height);
      }
    }

    function drawHUD() {
      const hudX = 14;
      const hudY = 16;
      const hudW = 228;
      const hudH = 104;
      ctx.save();
      ctx.shadowColor = "rgba(4, 10, 30, 0.8)";
      ctx.shadowBlur = 18;
      ctx.fillStyle = "rgba(8, 10, 26, 0.85)";
      ctx.fillRect(hudX, hudY, hudW, hudH);
      ctx.restore();
      ctx.strokeStyle = "rgba(133, 167, 255, 0.5)";
      ctx.lineWidth = 1.5;
      ctx.strokeRect(hudX, hudY, hudW, hudH);
      ctx.font = "bold 16px 'Segoe UI', system-ui";
      ctx.fillStyle = "#f8f9ff";
      ctx.fillText(`Level ${playerLevel}  XP: ${playerXP}/${xpForNextLevel}`, hudX + 12, hudY + 28);
      ctx.font = "16px 'Segoe UI', system-ui";
      ctx.fillText(`Money: $${playerMoney}`, hudX + 12, hudY + 52);
      if (gameState === GameState.LEVEL && currentContract) {
        ctx.fillStyle = "rgba(255,255,255,0.7)";
        ctx.fillText(`Payment: $${Math.round(currentContract.payment * missionPayMultiplier)}`, hudX + 12, hudY + 76);
        ctx.fillText(`Lives: ${livesRemaining}`, hudX + 12, hudY + 96);
      } else if (gameState === GameState.HUB) {
        ctx.fillStyle = portalActive ? "#7fffc7" : "#ff9f96";
        ctx.fillText(`Portal: ${portalActive ? "ONLINE" : "offline"}`, hudX + 12, hudY + 76);
        ctx.fillStyle = "rgba(255,255,255,0.65)";
        ctx.fillText("Press E/R near stations", hudX + 12, hudY + 96);
      }
    }

    function drawPortalGlow(isActive) {
      if (!isActive) return;
      const glowRadius = 140 + Math.sin(sliderTicker * 0.003) * 20;
      ctx.save();
      ctx.globalAlpha = 0.35;
      ctx.shadowBlur = 30;
      ctx.shadowColor = "rgba(105, 255, 215, 0.6)";
      ctx.fillStyle = "rgba(47, 189, 156, 0.25)";
      ctx.beginPath();
      ctx.ellipse(
        portalRect.x + portalRect.width / 2,
        portalRect.y + portalRect.height / 2,
        glowRadius,
        glowRadius * 0.5,
        0,
        0,
        Math.PI * 2
      );
      ctx.fill();
      ctx.restore();
    }

    function drawHub() {
      const playerRect = getPlayerRect();
      const nearComputer = rectsIntersect(playerRect, computerInteractRect);
      const nearShop = rectsIntersect(playerRect, shopInteractRect);
      ctx.fillStyle = "#2d2f44";
      ctx.fillRect(0, 0, screenWidth, floorY);
      ctx.fillStyle = "#141427";
      ctx.fillRect(hubDoorRect.x, hubDoorRect.y, hubDoorRect.width, hubDoorRect.height);
      ctx.fillStyle = "#6eeb80";
      ctx.fillRect(portalRect.x, portalRect.y, portalRect.width, portalRect.height);
      drawPortalGlow(portalActive);
      const portalOutline = portalActive ? "#8bf6c3" : "rgba(255,255,255,0.08)";
      ctx.strokeStyle = portalOutline;
      ctx.lineWidth = portalActive ? 3 : 1;
      ctx.strokeRect(
        portalRect.x - 6,
        portalRect.y - 8,
        portalRect.width + 12,
        portalRect.height + 16
      );
      ctx.lineWidth = 1;
      if (officeDecor === "plant") {
        ctx.fillStyle = "#7e4f24";
        ctx.fillRect(deskRect.right + 20, deskRect.top - 24, 20, 24);
        ctx.beginPath();
        ctx.arc(deskRect.right + 30, deskRect.top - 30, 18, 0, Math.PI * 2);
        ctx.fillStyle = "#4adc9c";
        ctx.fill();
      } else if (officeDecor === "poster") {
        const posterX = screenWidth - 260;
        ctx.fillStyle = "#1c2137";
        ctx.fillRect(posterX, 60, 140, 90);
        ctx.fillStyle = "#dfe5ff";
        ctx.fillRect(posterX + 10, 70, 120, 70);
        ctx.strokeStyle = "#5c6fa0";
        ctx.lineWidth = 2;
        ctx.strokeRect(posterX - 2, 58, 144, 94);
        ctx.lineWidth = 1;
      }
      ctx.fillStyle = "#383a50";
      ctx.fillRect(deskRect.x, deskRect.y, deskRect.width, deskRect.height);
      ctx.fillStyle = "#51535f";
      ctx.fillRect(shopCounterRect.x, shopCounterRect.y, shopCounterRect.width, shopCounterRect.height);
      ctx.fillStyle = "#0d111f";
      ctx.fillRect(deskRect.x + 42, deskRect.y - 72, 92, 46);
      ctx.fillStyle = "#19ffb0";
      ctx.fillRect(deskRect.x + 52, deskRect.y - 64, 72, 32);
      ctx.fillStyle = "#212336";
      ctx.fillRect(deskRect.x + 36, deskRect.y - 18, 108, 12);
      ctx.fillStyle = "#1c1d28";
      ctx.fillRect(shopCounterRect.x + 24, shopCounterRect.y - 68, 132, 52);
      ctx.fillStyle = "#ffb95c";
      ctx.fillRect(shopCounterRect.x + 34, shopCounterRect.y - 58, 112, 34);
      ctx.fillStyle = nearComputer ? "#a3f5ff" : "#cfd6f5";
      ctx.font = "12px 'Segoe UI', system-ui";
      ctx.fillText("COMPUTER", deskRect.x + 18, deskRect.y - 45);
      ctx.fillStyle = nearShop ? "#fff0b3" : "#ffe4a3";
      ctx.fillText("UPGRADES", shopCounterRect.x + 36, shopCounterRect.y - 42);
      ctx.font = "14px 'Segoe UI', system-ui";
      ctx.fillStyle = "#c4d9ff";
      ctx.fillText("Press E @ computer for contracts", deskRect.x + 12, deskRect.y - 10);
      ctx.fillText("Press R @ counter for upgrades", shopCounterRect.x + 8, shopCounterRect.y - 10);
      ctx.strokeStyle = nearComputer ? "#7fffc7" : "rgba(255,255,255,0.08)";
      ctx.lineWidth = nearComputer ? 3 : 1;
      ctx.strokeRect(
        computerInteractRect.x,
        computerInteractRect.y,
        computerInteractRect.width,
        computerInteractRect.height
      );
      ctx.strokeStyle = nearShop ? "#f0ffbc" : "rgba(255,255,255,0.06)";
      ctx.lineWidth = nearShop ? 3 : 1;
      ctx.strokeRect(
        shopInteractRect.x,
        shopInteractRect.y,
        shopInteractRect.width,
        shopInteractRect.height
      );
      ctx.lineWidth = 1;
    }

    function drawContractMenu() {
      const panelX = 140;
      const panelY = 120;
      const panelW = screenWidth - 280;
      const panelH = screenHeight - 240;
      ctx.fillStyle = "rgba(18,18,30,0.9)";
      ctx.fillRect(panelX, panelY, panelW, panelH);
      ctx.strokeStyle = "#a4b4f8";
      ctx.strokeRect(panelX, panelY, panelW, panelH);
      ctx.fillStyle = "#e7f0ff";
      ctx.font = "bold 24px 'Segoe UI', system-ui";
      ctx.fillText("Select Contract", panelX + 24, panelY + 44);
      let y = panelY + 90;
      contracts.forEach((contract, index) => {
        const selected = index === selectedContractIndex;
        ctx.fillStyle = selected ? "#7b90ff" : "#cfd7ff";
        ctx.fillText(`${contract.name} — $${Math.round(contract.payment * missionPayMultiplier)}`, panelX + 24, y);
        ctx.fillStyle = selected ? "#eef3ff" : "#b8bcd0";
        ctx.font = "14px 'Segoe UI', system-ui";
        ctx.fillText(`${contract.description}`, panelX + 24, y + 20);
        ctx.fillText(
          `XP ${contract.xp} · Lives ${contract.lives} · ${contract.label}`,
          panelX + 24,
          y + 40
        );
        y += 70;
        ctx.font = "bold 20px 'Segoe UI', system-ui";
      });
      ctx.font = "12px 'Segoe UI', system-ui";
      ctx.fillStyle = "#aab6ff";
      ctx.fillText("Enter/E to accept · Esc to cancel · W/S to navigate", panelX + 24, panelY + panelH - 30);
    }

    function drawShop() {
      const panelX = 160;
      const panelY = 120;
      const panelW = screenWidth - 320;
      const panelH = screenHeight - 240;
      ctx.fillStyle = "rgba(11,12,22,0.95)";
      ctx.fillRect(panelX, panelY, panelW, panelH);
      ctx.strokeStyle = "#7fffc7";
      ctx.strokeRect(panelX, panelY, panelW, panelH);
      ctx.fillStyle = "#e3fff7";
      ctx.font = "bold 24px 'Segoe UI', system-ui";
      ctx.fillText("Supply Depot", panelX + 24, panelY + 44);
      ctx.font = "16px 'Segoe UI', system-ui";
      const visibleItems = shopItems.slice(shopScrollOffset, shopScrollOffset + shopVisibleRows);
      visibleItems.forEach((item, idx) => {
        const actualIndex = shopScrollOffset + idx;
        const selected = actualIndex === shopSelectionIndex;
        const hasStock = (ownedUpgrades[item.key] || 0) < item.maxStacks;
        const y = panelY + 90 + idx * 90;
        ctx.fillStyle = selected ? "#2b2d5d" : "#161833";
        ctx.fillRect(panelX + 28, y - 12, panelW - 56, 70);
        ctx.fillStyle = selected ? "#fdfdf6" : "#d8dce8";
        ctx.fillText(item.name, panelX + 36, y + 6);
        ctx.fillStyle = "#9fd4ff";
        ctx.fillText(item.description, panelX + 36, y + 26);
        ctx.fillStyle = "#f8d59b";
        ctx.fillText(`$${item.cost}`, panelX + panelW - 120, y + 6);
        ctx.fillStyle = hasStock ? "#d0ffbd" : "#ffbaba";
        ctx.fillText(hasStock ? "Available" : "Owned", panelX + panelW - 120, y + 28);
      });
      ctx.font = "12px 'Segoe UI', system-ui";
      ctx.fillStyle = "#c8f8e6";
      ctx.fillText("Enter/E to purchase · Esc to exit · W/S to browse", panelX + 24, panelY + panelH - 50);
      ctx.fillText(shopMessage, panelX + 24, panelY + panelH - 24);
    }

    function drawWinScreen() {
      const panelX = 180;
      const panelY = 160;
      const panelW = screenWidth - 360;
      const panelH = screenHeight - 320;
      ctx.fillStyle = "rgba(14, 28, 16, 0.95)";
      ctx.fillRect(panelX, panelY, panelW, panelH);
      ctx.strokeStyle = "#adc3ff";
      ctx.strokeRect(panelX, panelY, panelW, panelH);
      ctx.fillStyle = "#d7ffe1";
      ctx.font = "28px 'Segoe UI', system-ui";
      ctx.fillText("Delivery Complete!", panelX + 40, panelY + 60);
      ctx.font = "18px 'Segoe UI', system-ui";
      const lines = [
        `Contract: ${winSummary.contract}`,
        `Earnings: $${winSummary.payment}`,
        `XP Gained: ${winSummary.xp}`,
        `Total Funds: $${winSummary.moneyTotal}`,
        `Level ${winSummary.level}  XP: ${playerXP}/${xpForNextLevel}`,
        "Press Enter/E to return to the office.",
      ];
      lines.forEach((line, i) => ctx.fillText(line, panelX + 40, panelY + 110 + i * 30));
    }

    function drawGameOver() {
      const panelX = 180;
      const panelY = 160;
      const panelW = screenWidth - 360;
      const panelH = screenHeight - 320;
      ctx.fillStyle = "rgba(60, 20, 25, 0.95)";
      ctx.fillRect(panelX, panelY, panelW, panelH);
      ctx.strokeStyle = "#ff6c80";
      ctx.strokeRect(panelX, panelY, panelW, panelH);
      ctx.fillStyle = "#ffe8e8";
      ctx.font = "28px 'Segoe UI', system-ui";
      ctx.fillText("Mission Failed", panelX + 40, panelY + 60);
      ctx.font = "18px 'Segoe UI', system-ui";
      const lines = [
        `Contract: ${gameOverSummary.contract}`,
        `Reason: ${gameOverSummary.reason}`,
        "Press Enter/E to return to the office.",
      ];
      lines.forEach((line, i) => ctx.fillText(line, panelX + 40, panelY + 120 + i * 28));
    }

    function draw() {
      drawBackground();
      if (gameState === GameState.LEVEL && currentContract) {
        drawLevel();
      } else {
        drawHub();
      }
      drawPlayer();
      drawHUD();
      if (gameState === GameState.CONTRACT_MENU) {
        drawContractMenu();
      }
      if (gameState === GameState.SHOP) {
        drawShop();
      }
      if (gameState === GameState.WIN) {
        drawWinScreen();
      }
      if (gameState === GameState.GAME_OVER) {
        drawGameOver();
      }
    }

    refreshContracts();
    requestAnimationFrame((time) => {
      lastTimestamp = time;
      loop(time);
    });
  </script>
</body>
</html>
